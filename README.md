# Робота з посиланнями на об'єкти
**Мета:** написати, відлагодити та протестувати програму, у якій створити клас для обробки даних Ознайомитися з концепцією посилань (references) у мові програмування C++, навчитися оголошувати їх, розуміти їхню відмінність від вказівників (pointers) та використовувати в якості параметрів функцій для ефективної передачі даних.

## Вказівки до роботи
Відповідно до цієї інструкції вам потрібно у середовищі Visual Studio Code з використанням набору компіляторів GCC створити програму мовою C++ з класом для обробки даних та реалізувати конструктор за замовчуванням, конструктори з параметрами, деструктор. Також потрібно продемонструвати застосування кожного з методів класу. Методи зміни полів класу повинні перевіряти валідність заданих змінних.
1.	Оголосити клас, його полів та методів.
2.	Вибрати завдання згідно свого варіанту у ДОДАТКУ.
3.	Розробити блок-схему алгоритму програми.
4.	Реалізувати програму для виводу даних полів (членів) класу.

### Короткі відомості
**Посилання (Reference)** — це альтернативне ім'я, або псевдонім, для вже існуючої змінної. Воно дозволяє отримувати доступ до тієї ж області пам'яті, що й оригінальна змінна. Коли ви оголошуєте посилання, воно має бути відразу ініціалізоване, і його не можна "перепризначити" для посилання на іншу змінну.

Синтаксис оголошення:
`тип& ім'я_посилання = ім'я_змінної;`
На відміну від вказівників:
- посилання не вимагають використання оператора розіменування `*`.
- посилання не можуть бути `nullptr`.
- після ініціалізації посилання завжди прив'язане до однієї змінної.

Використання посилань як параметрів функцій (передача за посиланням) є дуже ефективним способом передачі великих об'єктів без створення їхньої копії. Це дозволяє функції змінювати значення оригінальної змінної.

Розглянемо приклад, який демонструє, як клас *Student* може бути використаний разом з посиланнями для маніпуляції даними.

Спочатку давайте визначимо простий клас *Student*. Цей клас міститиме приватні члени для зберігання імені та віку, а також публічні методи для доступу до них. Використання приватних членів допомагає інкапсулювати дані, що є однією з ключових концепцій об'єктно-орієнтованого програмування.

```c++
#include <iostream>
#include <string>

// Визначення класу Student
class Student {
private:
    std::string name;
    int age;
public:
    // Конструктор класу
    Student(const std::string& studentName, int studentAge) {
        name = studentName;
        age = studentAge;
    }
    // Метод для виведення інформації про студента
    void displayInfo() const {
        std::cout << "Name: " << name << ", Age: " << age << std::endl;
    }
    // Метод для зміни віку студента
    void setAge(int newAge) {
        age = newAge;
    }
};
```
Тепер створимо функцію, яка приймає посилання на об'єкт `Student`. Це дозволяє змінювати оригінальний об'єкт без створення його копії. Це дуже ефективно з точки зору пам'яті, особливо для великих об'єктів. Замість того, щоб передавати весь об'єкт, ми передаємо лише адресу, що вказує на його місце розташування в пам'яті.
```c++
// Функція, що приймає посилання на об'єкт Student
void changeStudentAge(Student& student, int newAge) {
    std::cout << "Changing student's age using a reference..." << std::endl;
    student.setAge(newAge);
}

int main() {
    // Створення об'єкта класу Student
    Student student1("Ivan", 20);

    // Виведення початкової інформації
    std::cout << "Initial student info:" << std::endl;
    student1.displayInfo();

    // Виклик функції, що змінює вік студента через посилання
    changeStudentAge(student1, 22);

    // Виведення оновленої інформації
    std::cout << "\nUpdated student info:" << std::endl;
    student1.displayInfo();

    return 0;
}
```
Клас *Student*: Ми визначили клас *Student* з двома приватними полями (`name` та `age`) і трьома публічними методами. Приватні поля не можуть бути доступні безпосередньо ззовні класу, що забезпечує інкапсуляцію. Публічні методи `displayInfo()` та `setAge()` надають контрольований доступ до цих даних.

Посилання (&): У функції `changeStudentAge`, параметр `Student& student` оголошено як посилання на об'єкт `Student`. Коли ми викликаємо цю функцію, передаючи `student1`, ми не створюємо копію `student1`. Натомість, student стає псевдонімом для `student1`. Будь-які зміни, зроблені через цей псевдонім, безпосередньо впливають на оригінальний об'єкт. Це особливо корисно, коли потрібно передавати об'єкти в функції для їх зміни, уникаючи при цьому ресурсів на копіювання.

Цей приклад демонструє, як класи та посилання можуть працювати разом для створення структурованого та ефективного коду, де об'єкти інкапсулюють дані та поведінку, а посилання забезпечують швидкий та безпечний спосіб взаємодії з цими об'єктами.

### Оформлення звіту
У звіті студент має вказати свій варіант індивідуального завдання та представити:
1.	Блок-схему алгоритму програми.
2.	Код (лістинг) програми.
3.	Результати тестування для різних вхідних умов.
4.	Конструктивний висновок — що ви дізналися нового, чого навчилися, якими способами та інструментами досягнули мети.

## ДОДАТОК

### Варіанти завдань

|  № |              Клас             |                              Поля класу                                 |
|----|-------------------------------|-------------------------------------------------------------------------|
|  1 | Резистор                      | Номінальний опір, максимальна потужність розсіяння, клас точності       |
|  2 | Конденсатор                   | Номінальна ємність, максимальна напруга, тип матеріалу                  |
|  3 | Транзистор                    | Тип, коефіцієнт підсилення, максимальний струм                          |
|  4 | Діод                          | Пряма напруга, максимальний зворотний струм, призначення                |
|  5 | Операційний підсилювач        | Коефіцієнт підсилення, напруга живлення, кількість входів               |
|  6 | Котушка індуктивності         | Індуктивність, опір, кількість витків                                   |
|  7 | Радіопередавач                | Робоча частота, потужність, тип модуляції                               |
|  8 | Антена                        | Тип, коефіцієнт підсилення, частотний діапазон                          |
|  9 | Радіоприймач                  | Робоча частота, чутливість, тип модуляції                               |
| 10 | Осцилограф                    | Кількість каналів, смуга пропускання, тип (аналоговий/цифровий)         |
| 11 | Акумулятор                    | Ємність, напруга, тип матеріалу                                         |
| 12 | Мікросхема                    | Назва/маркування, кількість виводів, напруга живлення                   |
| 13 | Коаксіальний кабель           | Хвильовий опір, діаметр, довжина                                        |
| 14 | Датчик температури            | Тип, діапазон вимірювання, точність                                     |
| 15 | Друкована плата               | Ширина, довжина, кількість шарів                                        |
| 16 | Світлодіод                    | Колір, робочий струм, напруга                                           |
| 17 | Оптоволоконний кабель         | Кількість волокон, тип, довжина                                         |
| 18 | Аналого-цифровий перетворювач | Розрядність, частота дискретизації, кількість каналів                   |
| 19 | Мікроконтролер                | Архітектура, частота, кількість портів                                  |
| 20 | Радіореле                     | Напруга котушки, максимальний струм комутації, кількість груп контактів |
| 21 | Акустичний динамік            | Опір, потужність, діаметр                                               |
| 22 | Трансформатор                 | Коефіцієнт трансформації, первинна напруга, потужність                  |
| 23 | Генератор сигналів            | Тип сигналу, максимальна частота, наявність модуляції                   |
| 24 | Атенюатор                     | Коефіцієнт послаблення, максимальна потужність, тип                     |
| 25 | Електронний фільтр            | Тип, частота зрізу, порядок                                             |
| 26 | Телевізор                     | Діагональ екрану, роздільна здатність, наявність Smart-TV               |
| 27 | Супутник зв’язку              | Тип орбіти, кількість транспондерів, частотний діапазон                 |
| 28 | Роутер                        | Швидкість передавання даних, стандарт WiFi, кількість портів LAN        |
| 29 | Сигналізація                  | Кількість датчиків, наявність бездротових сенсорів, спосіб оповіщення   |
| 30 | Ретранслятор                  | Коефіцієнт підсилення, тип, робоча частота                              |
